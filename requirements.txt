## Core Logic Breakdown by File

---

## **1. `chroma_manager.py` - The Database Gatekeeper**

### **Responsibilities:**

**A. Singleton Connection Management**
- Create ONE ChromaDB client instance that persists across Streamlit reruns
- Use Streamlit's `@st.cache_resource` decorator to prevent reloading 51K vectors every interaction
- Store the client and collection as cached objects

**B. Collection Loader**
- Function: `get_collection()` 
- Returns the ChromaDB collection object
- If collection doesn't exist, raise clear error with instructions to run `build_vector.py`

**C. Health Check**
- Function: `validate_database()`
- Checks: Collection exists, has documents (count > 0), embedding function matches
- Returns: Boolean + error message if failed
- Called once when app starts to show user-friendly errors early

**D. Stats Provider**
- Function: `get_collection_stats()`
- Returns: Total movie count, genre distribution, year range
- Used by UI to show "Searching 51,234 movies" message

**Key Design:** This file knows NOTHING about movies, genres, or scoring. It's purely a database wrapper.

---

## **2. `query_engine.py` - The Search Intelligence**

### **Responsibilities:**

**A. Main Search Function: `search_movies(query, filters, boost_weight, sort_by, n_results)`**

**Parameters:**
- `query`: String (can be empty)
- `filters`: Dict with keys: `genres` (list), `year_range` (tuple), `min_rating` (float), `safe_search` (bool)
- `boost_weight`: Float 0.0-0.20 (user-controlled popularity boost)
- `sort_by`: Enum: "relevance", "rating", "popularity", "newest"
- `n_results`: Int (default 20)

**Logic Flow:**

**Step 1: Build ChromaDB WHERE clause**
```
Start with: adult = False (if safe_search ON)

If genres selected (e.g., [28, 878, 18]):
    Add OR logic: genre_28 OR genre_878 OR genre_18
    
If year_range specified (e.g., 2010-2020):
    Add: release_year >= 2010 AND release_year <= 2020
    
If min_rating set (e.g., 7.0):
    Add: vote_average >= 7.0
```

**Step 2: Handle Empty Query Edge Case**
```
If query is empty:
    Fetch n_results * 3 movies matching filters
    Sort by vote_count descending
    Return top n_results
    (This shows "popular movies in this genre")
```

**Step 3: Execute Vector Search**
```
If query NOT empty:
    Embed the query text using same model (all-MiniLM-L6-v2)
    
    Fetch n_results * 2 (over-fetch for re-ranking)
    
    Apply WHERE filters from Step 1
```

**Step 4: Apply Popularity Boost (if boost_weight > 0)**
```
For each result:
    semantic_score = result['distance']  (0-1, higher is better)
    
    popularity_normalized = log(vote_count) / log(max_vote_count_in_results)
    
    final_score = semantic_score * (1 - boost_weight) + popularity_normalized * boost_weight

Example with boost_weight = 0.10:
    Movie A: semantic=0.85, popularity_norm=0.90
    Final = 0.85 * 0.90 + 0.90 * 0.10 = 0.765 + 0.09 = 0.855
    
    Movie B: semantic=0.82, popularity_norm=0.30
    Final = 0.82 * 0.90 + 0.30 * 0.10 = 0.738 + 0.03 = 0.768
```

**Step 5: Apply Secondary Sorting**
```
If sort_by == "relevance":
    Keep current order (already sorted by final_score)
    
If sort_by == "rating":
    Re-sort by vote_average DESC
    (But only among movies with vote_count > 100 to avoid flukes)
    
If sort_by == "popularity":
    Re-sort by vote_count DESC
    
If sort_by == "newest":
    Re-sort by release_year DESC
```

**Step 6: Trim to Final Count**
```
Return exactly n_results movies
```

**B. Result Formatting Function: `format_results(raw_results)`**

Takes ChromaDB output and returns clean dicts:
```
{
    'movie_id': int,
    'title': str,
    'year': int,
    'rating': float,
    'vote_count': int,
    'genres': str,  (already formatted as "Action, Sci-Fi")
    'poster_path': str,  (just the partial path, UI handles full URL)
    'overview': str,  (full text, UI will truncate for display)
    'tagline': str,
    'similarity_score': float,  (for debugging/display)
    'is_adult': bool
}
```

**C. Smoke Test Function: `run_smoke_tests()`**

Not exposed in UI, but useful for validation:
```
Test 1: Exact title match
    Query: "The Matrix"
    Assert: Top result is "The Matrix" with score > 0.85
    
Test 2: Semantic match
    Query: "movies about dreams"
    Assert: "Inception" appears in top 5
    
Test 3: Empty query with genre filter
    Query: ""
    Filters: genres=[28]  (Action)
    Assert: Returns popular action movies sorted by vote_count
    
Test 4: Adult content filtering
    Query: "romance"
    Filters: safe_search=True
    Assert: No results have is_adult=True
```

**Key Design:** This file knows NOTHING about UI. It's a pure API that takes parameters and returns data.

---

## **3. `app.py` - The User Experience**

### **Responsibilities:**

**A. Page Configuration**
- Set page title, icon, layout (wide mode for grid display)
- Initialize session state for filters (persists across Streamlit reruns)

**B. Sidebar - Filter Controls**

**Section 1: Search Box**
- Text input (can be empty)
- Placeholder: "e.g., 'sad robots', 'heist movie', 'samurai revenge'"

**Section 2: Popularity Boost Slider**
- Label: "Boost Popular Movies"
- Range: 0% to 20%
- Default: 0%
- Help text: "Higher values favor well-known movies over best semantic match"

**Section 3: Genres (Collapsible)**
- Multi-select checkbox group
- Show first 6 genres by default (Action, Comedy, Drama, Horror, Sci-Fi, Romance)
- "Show more" expander for remaining 13
- Clear all button

**Section 4: Release Year (Collapsible)**
- Range slider: 1920 to 2024
- Default: Full range
- Show selected range as text above slider

**Section 5: Minimum Rating (Collapsible)**
- Slider: 0.0 to 10.0, step 0.5
- Default: 0.0 (no filter)
- Help text: "Only show movies rated X or higher"

**Section 6: Safe Search Toggle**
- Checkbox: "Hide adult content"
- Default: OFF (per your decision)
- Warning icon if OFF

**Section 7: Sort By**
- Radio buttons:
  - Best Match (default)
  - Highest Rated
  - Most Popular  
  - Newest First
- Only visible if query is NOT empty (sorting popular movies makes no sense)

**C. Main Content Area**

**Top Bar:**
- Result count: "Found 247 movies" or "Showing popular Action movies"
- If boost_weight > 0: Small badge "Popularity boost: 15%"

**Results Grid:**
- 4 columns on desktop, 2 on tablet, 1 on mobile
- Each card shows:
  - Poster (clickable to expand)
  - Title
  - Year + Rating (⭐ 8.3)
  - Genre tags (max 3, truncated with "...")
  - Similarity score badge (only if query was semantic search, not popular fallback)
  
**Card Interaction:**
- Click poster → Expands to show full overview + tagline
- Hover → Show truncated overview (first 150 chars)

**Empty State Handling:**
```
If no results at all:
    Message: "No matches found for '[query]' with current filters"
    Suggestion: "Try: Remove some filters, or use broader search terms"
    Fallback: Show 10 random popular movies as "You might like..."
```

**D. Advanced: Overview Truncation Logic**

In the hover tooltip or card display:
```
If overview length > 150 chars:
    Show first 147 chars + "..."
    
In expanded view:
    Show full overview (no truncation)
```

**E. Poster URL Construction**

When rendering image:
```
If poster_path is not empty:
    Full URL = "https://image.tmdb.org/t/p/w500" + poster_path
Else:
    Show placeholder image (generic film reel icon)
```

**F. Performance Optimization**

**Debounce Search:**
- Don't query ChromaDB on every keystroke
- Wait 500ms after user stops typing before searching
- Show loading spinner during search

**Cache Results:**
- If user just changes sort order (not filters/query), don't re-search
- Just re-sort the existing results in memory

**G. Error Handling**

```
If chroma_manager.validate_database() fails:
    Show big red banner: "Database not found. Run 'python build_vector.py' first."
    Disable all search controls
    
If query_engine.search_movies() throws error:
    Show: "Search error occurred. Try again or simplify your query."
    Log full error to console for debugging
```

**H. Debug Mode (Optional)**

Add a hidden checkbox in sidebar (collapsed by default):
```
If debug mode ON:
    Show for each result:
        - Raw similarity score
        - Popularity score component
        - Final blended score
        - Which filters matched
        - Embedding text preview (first 100 chars)
```

---

## **Data Flow Summary**

```
User types "sad robots" + selects "Sci-Fi" genre + sets boost to 10%
    ↓
app.py validates inputs
    ↓
Calls query_engine.search_movies(
    query="sad robots",
    filters={genres: [878], safe_search: False},
    boost_weight=0.10,
    sort_by="relevance",
    n_results=20
)
    ↓
query_engine builds WHERE clause for ChromaDB
    ↓
query_engine calls chroma_manager.get_collection()
    ↓
ChromaDB returns 40 movies (over-fetched for re-ranking)
    ↓
query_engine applies popularity boost formula
    ↓
query_engine sorts and trims to 20
    ↓
query_engine formats results into clean dicts
    ↓
Returns to app.py
    ↓
app.py renders 20 movie cards in 4-column grid
```

---

## **Key Architectural Principles**

1. **Separation of Concerns:** UI knows nothing about ChromaDB. Search engine knows nothing about Streamlit.

2. **Testability:** You can call `query_engine.search_movies()` from a Python shell without running the UI.

3. **User Control:** Popularity boost is transparent and adjustable, not hidden magic.

4. **Graceful Degradation:** Empty queries, missing posters, no results - all handled with fallbacks.

5. **Performance First:** Cache database connection, debounce search, over-fetch for re-ranking.

---

## **Missing Pieces You'll Need to Decide Later**

1. **"More Like This" button:** If you add it, where does that logic go? Probably a second function in `query_engine.py` called `find_similar(movie_id, n_results)`.

2. **Pagination:** Right now you fetch 20 and show 20. If you want "Load More", you'll need to track offset in session state.

3. **Search History:** Should recent searches appear in a dropdown? Needs session state in `app.py`.

4. **Export Results:** Should users be able to download their search results as CSV? Needs export function in `app.py`.

This is your complete feature spec. Ready to build?